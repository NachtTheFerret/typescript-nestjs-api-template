// # This file was generated by a custom script for Prisma entity service setup.
// # Do not modify this file directly, as changes may be overwritten.

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma.service';
import type { __ENTITY_NAME__, Prisma } from '@prisma/client';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class __ENTITY_NAME__EntityService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly events: EventEmitter2
  ) {}

  /**
   * Get a __ENTITY_PROPERTY_NAME__ by ID
   * @param id __ENTITY_NAME__ ID
   * @param options Additional Prisma findUnique options
   * @returns __ENTITY_NAME__ or null if not found
   */
  public async get(id: string, options: Omit<Prisma.__ENTITY_NAME__FindUniqueArgs, 'where'> = {}): Promise<__ENTITY_NAME__ | null> {
    const __ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.findUnique({ where: { id }, ...options });

    if (__ENTITY_PROPERTY_NAME__) this.events.emit('entity.__ENTITY_PROPERTY_NAME__.accessed.single', __ENTITY_PROPERTY_NAME__, { where: { id }, ...options });

    return __ENTITY_PROPERTY_NAME__;
  }

  /**
   * Find a __ENTITY_PROPERTY_NAME__ by criteria
   * @param where Search criteria
   * @param options Additional Prisma findFirst options
   * @returns __ENTITY_NAME__ or null if not found
   */
  public async find(
    where: Prisma.__ENTITY_NAME__WhereInput = {},
    options: Omit<Prisma.__ENTITY_NAME__FindFirstArgs, 'where'> = {}
  ): Promise<__ENTITY_NAME__ | null> {
    const __ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.findFirst({ where, ...options });

    if (__ENTITY_PROPERTY_NAME__) this.events.emit('entity.__ENTITY_PROPERTY_NAME__.accessed.single', __ENTITY_PROPERTY_NAME__, { where, ...options });

    return __ENTITY_PROPERTY_NAME__;
  }

  /**
   * Find multiple __MULTIPLE_ENTITY_PROPERTY_NAME__ by criteria
   * @param where Search criteria
   * @param options Additional Prisma findMany options
   * @returns Array of __MULTIPLE_ENTITY_PROPERTY_NAME__
   */
  public async findMany(
    where: Prisma.__ENTITY_NAME__WhereInput = {},
    options: Omit<Prisma.__ENTITY_NAME__FindManyArgs, 'where'> = {}
  ): Promise<__ENTITY_NAME__[]> {
    const __MULTIPLE_ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.findMany({ where, ...options });

    if (__MULTIPLE_ENTITY_PROPERTY_NAME__.length > 0) this.events.emit('entity.__ENTITY_PROPERTY_NAME__.accessed.multiple', __MULTIPLE_ENTITY_PROPERTY_NAME__, { where, ...options });

    return __MULTIPLE_ENTITY_PROPERTY_NAME__;
  }

  /**
   * Create a new __ENTITY_PROPERTY_NAME__
   * @param data __ENTITY_NAME__ data
   * @param options Additional Prisma create options
   * @returns Created __ENTITY_PROPERTY_NAME__
   */
  public async create(data: Prisma.__ENTITY_NAME__CreateInput, options: Omit<Prisma.__ENTITY_NAME__CreateArgs, 'data'> = {}): Promise<__ENTITY_NAME__> {
    const __ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.create({ data, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.created.single', __ENTITY_PROPERTY_NAME__, { data, ...options });

    return __ENTITY_PROPERTY_NAME__;
  }

  /**
   * Create multiple __MULTIPLE_ENTITY_PROPERTY_NAME__
   * @param data Array of __ENTITY_PROPERTY_NAME__ data
   * @param options Additional Prisma createMany options
   * @returns Batch payload with count of created records
   */
  public async createMany(
    data: Prisma.__ENTITY_NAME__CreateManyInput[],
    options: Omit<Prisma.__ENTITY_NAME__CreateManyArgs, 'data'> = {}
  ): Promise<Prisma.BatchPayload> {
    const __MULTIPLE_ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.createMany({ data, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.created.multiple', __MULTIPLE_ENTITY_PROPERTY_NAME__, { data, ...options });

    return __MULTIPLE_ENTITY_PROPERTY_NAME__;
  }

  /**
   * Upsert a __ENTITY_PROPERTY_NAME__ (create or update)
   * @param where Unique criteria to find the __ENTITY_PROPERTY_NAME__
   * @param createData Data to create if __ENTITY_PROPERTY_NAME__ does not exist
   * @param updateData Data to update if __ENTITY_PROPERTY_NAME__ exists
   * @param options Additional Prisma upsert options
   * @returns Upserted __ENTITY_PROPERTY_NAME__
   */
  public async upsert(
    where: Prisma.__ENTITY_NAME__WhereUniqueInput,
    createData: Prisma.__ENTITY_NAME__CreateInput,
    updateData: Prisma.__ENTITY_NAME__UpdateInput,
    options: Omit<Prisma.__ENTITY_NAME__UpsertArgs, 'where' | 'create' | 'update'> = {}
  ): Promise<__ENTITY_NAME__> {
    const __ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.upsert({ where, create: createData, update: updateData, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.upserted', __ENTITY_PROPERTY_NAME__, { where, create: createData, update: updateData, ...options });

    return __ENTITY_PROPERTY_NAME__;
  }

  /**
   * Update a __ENTITY_PROPERTY_NAME__ by ID
   * @param id __ENTITY_NAME__ ID
   * @param data Data to update
   * @param options Additional Prisma update options
   * @returns Updated __ENTITY_PROPERTY_NAME__
   */
  public async update(
    id: string,
    data: Prisma.__ENTITY_NAME__UpdateInput,
    options: Omit<Prisma.__ENTITY_NAME__UpdateArgs, 'where' | 'data'> = {}
  ): Promise<__ENTITY_NAME__> {
    const __ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.update({ where: { id }, data, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.updated.single', __ENTITY_PROPERTY_NAME__, { id, data, ...options });

    return __ENTITY_PROPERTY_NAME__;
  }

  /**
   * Update multiple __MULTIPLE_ENTITY_PROPERTY_NAME__ by criteria
   * @param where Criteria to select __MULTIPLE_ENTITY_PROPERTY_NAME__ to update
   * @param data Data to update
   * @param options Additional Prisma updateMany options
   * @returns Batch payload with count of updated records
   */
  public async updateMany(
    where: Prisma.__ENTITY_NAME__WhereInput,
    data: Prisma.__ENTITY_NAME__UpdateManyMutationInput,
    options: Omit<Prisma.__ENTITY_NAME__UpdateManyArgs, 'where' | 'data'> = {}
  ): Promise<Prisma.BatchPayload> {
    const __MULTIPLE_ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.updateMany({ where, data, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.updated.multiple', __MULTIPLE_ENTITY_PROPERTY_NAME__, { where, data, ...options });

    return __MULTIPLE_ENTITY_PROPERTY_NAME__;
  }

  /**
   * Delete a __ENTITY_PROPERTY_NAME__ by ID
   * @param id __ENTITY_NAME__ ID
   * @param options Additional Prisma delete options
   * @returns Deleted __ENTITY_PROPERTY_NAME__
   */
  public async delete(id: string, options: Omit<Prisma.__ENTITY_NAME__DeleteArgs, 'where'> = {}): Promise<__ENTITY_NAME__> {
    const __ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.delete({ where: { id }, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.deleted.single', __ENTITY_PROPERTY_NAME__, { id, ...options });

    return __ENTITY_PROPERTY_NAME__;
  }

  /**
   * Delete multiple __MULTIPLE_ENTITY_PROPERTY_NAME__ by criteria
   * @param where Criteria to select __MULTIPLE_ENTITY_PROPERTY_NAME__ to delete
   * @param options Additional Prisma deleteMany options
   * @returns Batch payload with count of deleted records
   */
  public async deleteMany(
    where: Prisma.__ENTITY_NAME__WhereInput,
    options: Omit<Prisma.__ENTITY_NAME__DeleteManyArgs, 'where'> = {}
  ): Promise<Prisma.BatchPayload> {
    const __MULTIPLE_ENTITY_PROPERTY_NAME__ = await this.prisma.__ENTITY_PROPERTY_NAME__.deleteMany({ where, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.deleted.multiple', __MULTIPLE_ENTITY_PROPERTY_NAME__, { where, ...options });

    return __MULTIPLE_ENTITY_PROPERTY_NAME__;
  }

  /**
   * Aggregate __MULTIPLE_ENTITY_PROPERTY_NAME__ by criteria
   * @param where Criteria to filter __MULTIPLE_ENTITY_PROPERTY_NAME__
   * @param options Prisma aggregate options (excluding 'where')
   * @returns Aggregated __ENTITY_PROPERTY_NAME__ data
   */
  public async aggregate(where: Prisma.__ENTITY_NAME__WhereInput = {}, options: Omit<Prisma.__ENTITY_NAME__AggregateArgs, 'where'> = {}) {
    const result = await this.prisma.__ENTITY_PROPERTY_NAME__.aggregate({ where, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.aggregated', result, { where, ...options });

    return result;
  }

  /**
   * Count __MULTIPLE_ENTITY_PROPERTY_NAME__ by criteria
   * @param where Criteria to count __MULTIPLE_ENTITY_PROPERTY_NAME__
   * @param options Additional Prisma count options
   * @returns Count of __MULTIPLE_ENTITY_PROPERTY_NAME__ matching criteria
   */
  public async count(where: Prisma.__ENTITY_NAME__WhereInput = {}, options: Omit<Prisma.__ENTITY_NAME__CountArgs, 'where'> = {}) {
    const count = await this.prisma.__ENTITY_PROPERTY_NAME__.count({ where, ...options });

    this.events.emit('entity.__ENTITY_PROPERTY_NAME__.counted', count, { where, ...options });

    return count;
  }
}
