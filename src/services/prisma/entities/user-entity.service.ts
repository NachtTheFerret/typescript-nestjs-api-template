// # This file was generated by a custom script for Prisma entity service setup.
// # Do not modify this file directly, as changes may be overwritten.

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma.service';
import type { User, Prisma } from '@prisma/client';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class UserEntityService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly events: EventEmitter2
  ) {}

  /**
   * Get a user by ID
   * @param id User ID
   * @param options Additional Prisma findUnique options
   * @returns User or null if not found
   */
  public async get(id: string, options: Omit<Prisma.UserFindUniqueArgs, 'where'> = {}): Promise<User | null> {
    const user = await this.prisma.user.findUnique({ where: { id }, ...options });

    if (user) this.events.emit('entity.user.accessed.single', user, { where: { id }, ...options });

    return user;
  }

  /**
   * Find a user by criteria
   * @param where Search criteria
   * @param options Additional Prisma findFirst options
   * @returns User or null if not found
   */
  public async find(
    where: Prisma.UserWhereInput = {},
    options: Omit<Prisma.UserFindFirstArgs, 'where'> = {}
  ): Promise<User | null> {
    const user = await this.prisma.user.findFirst({ where, ...options });

    if (user) this.events.emit('entity.user.accessed.single', user, { where, ...options });

    return user;
  }

  /**
   * Find multiple users by criteria
   * @param where Search criteria
   * @param options Additional Prisma findMany options
   * @returns Array of users
   */
  public async findMany(
    where: Prisma.UserWhereInput = {},
    options: Omit<Prisma.UserFindManyArgs, 'where'> = {}
  ): Promise<User[]> {
    const users = await this.prisma.user.findMany({ where, ...options });

    if (users.length > 0) this.events.emit('entity.user.accessed.multiple', users, { where, ...options });

    return users;
  }

  /**
   * Create a new user
   * @param data User data
   * @param options Additional Prisma create options
   * @returns Created user
   */
  public async create(data: Prisma.UserCreateInput, options: Omit<Prisma.UserCreateArgs, 'data'> = {}): Promise<User> {
    const user = await this.prisma.user.create({ data, ...options });

    this.events.emit('entity.user.created.single', user, { data, ...options });

    return user;
  }

  /**
   * Create multiple users
   * @param data Array of user data
   * @param options Additional Prisma createMany options
   * @returns Batch payload with count of created records
   */
  public async createMany(
    data: Prisma.UserCreateManyInput[],
    options: Omit<Prisma.UserCreateManyArgs, 'data'> = {}
  ): Promise<Prisma.BatchPayload> {
    const users = await this.prisma.user.createMany({ data, ...options });

    this.events.emit('entity.user.created.multiple', users, { data, ...options });

    return users;
  }

  /**
   * Upsert a user (create or update)
   * @param where Unique criteria to find the user
   * @param createData Data to create if user does not exist
   * @param updateData Data to update if user exists
   * @param options Additional Prisma upsert options
   * @returns Upserted user
   */
  public async upsert(
    where: Prisma.UserWhereUniqueInput,
    createData: Prisma.UserCreateInput,
    updateData: Prisma.UserUpdateInput,
    options: Omit<Prisma.UserUpsertArgs, 'where' | 'create' | 'update'> = {}
  ): Promise<User> {
    const user = await this.prisma.user.upsert({ where, create: createData, update: updateData, ...options });

    this.events.emit('entity.user.upserted', user, { where, create: createData, update: updateData, ...options });

    return user;
  }

  /**
   * Update a user by ID
   * @param id User ID
   * @param data Data to update
   * @param options Additional Prisma update options
   * @returns Updated user
   */
  public async update(
    id: string,
    data: Prisma.UserUpdateInput,
    options: Omit<Prisma.UserUpdateArgs, 'where' | 'data'> = {}
  ): Promise<User> {
    const user = await this.prisma.user.update({ where: { id }, data, ...options });

    this.events.emit('entity.user.updated.single', user, { id, data, ...options });

    return user;
  }

  /**
   * Update multiple users by criteria
   * @param where Criteria to select users to update
   * @param data Data to update
   * @param options Additional Prisma updateMany options
   * @returns Batch payload with count of updated records
   */
  public async updateMany(
    where: Prisma.UserWhereInput,
    data: Prisma.UserUpdateManyMutationInput,
    options: Omit<Prisma.UserUpdateManyArgs, 'where' | 'data'> = {}
  ): Promise<Prisma.BatchPayload> {
    const users = await this.prisma.user.updateMany({ where, data, ...options });

    this.events.emit('entity.user.updated.multiple', users, { where, data, ...options });

    return users;
  }

  /**
   * Delete a user by ID
   * @param id User ID
   * @param options Additional Prisma delete options
   * @returns Deleted user
   */
  public async delete(id: string, options: Omit<Prisma.UserDeleteArgs, 'where'> = {}): Promise<User> {
    const user = await this.prisma.user.delete({ where: { id }, ...options });

    this.events.emit('entity.user.deleted.single', user, { id, ...options });

    return user;
  }

  /**
   * Delete multiple users by criteria
   * @param where Criteria to select users to delete
   * @param options Additional Prisma deleteMany options
   * @returns Batch payload with count of deleted records
   */
  public async deleteMany(
    where: Prisma.UserWhereInput,
    options: Omit<Prisma.UserDeleteManyArgs, 'where'> = {}
  ): Promise<Prisma.BatchPayload> {
    const users = await this.prisma.user.deleteMany({ where, ...options });

    this.events.emit('entity.user.deleted.multiple', users, { where, ...options });

    return users;
  }

  /**
   * Aggregate users by criteria
   * @param where Criteria to filter users
   * @param options Prisma aggregate options (excluding 'where')
   * @returns Aggregated user data
   */
  public async aggregate(where: Prisma.UserWhereInput = {}, options: Omit<Prisma.UserAggregateArgs, 'where'> = {}) {
    const result = await this.prisma.user.aggregate({ where, ...options });

    this.events.emit('entity.user.aggregated', result, { where, ...options });

    return result;
  }

  /**
   * Count users by criteria
   * @param where Criteria to count users
   * @param options Additional Prisma count options
   * @returns Count of users matching criteria
   */
  public async count(where: Prisma.UserWhereInput = {}, options: Omit<Prisma.UserCountArgs, 'where'> = {}) {
    const count = await this.prisma.user.count({ where, ...options });

    this.events.emit('entity.user.counted', count, { where, ...options });

    return count;
  }
}
