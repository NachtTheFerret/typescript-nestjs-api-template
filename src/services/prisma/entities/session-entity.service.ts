// # This file was generated by a custom script for Prisma entity service setup.
// # Do not modify this file directly, as changes may be overwritten.

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma.service';
import type { Session, Prisma } from '@prisma/client';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class SessionEntityService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly events: EventEmitter2
  ) {}

  /**
   * Get a session by ID
   * @param id Session ID
   * @param options Additional Prisma findUnique options
   * @returns Session or null if not found
   */
  public async get(id: string, options: Omit<Prisma.SessionFindUniqueArgs, 'where'> = {}): Promise<Session | null> {
    const session = await this.prisma.session.findUnique({ where: { id }, ...options });

    if (session) this.events.emit('entity.session.accessed.single', session, { where: { id }, ...options });

    return session;
  }

  /**
   * Find a session by criteria
   * @param where Search criteria
   * @param options Additional Prisma findFirst options
   * @returns Session or null if not found
   */
  public async find(
    where: Prisma.SessionWhereInput = {},
    options: Omit<Prisma.SessionFindFirstArgs, 'where'> = {}
  ): Promise<Session | null> {
    const session = await this.prisma.session.findFirst({ where, ...options });

    if (session) this.events.emit('entity.session.accessed.single', session, { where, ...options });

    return session;
  }

  /**
   * Find multiple sessions by criteria
   * @param where Search criteria
   * @param options Additional Prisma findMany options
   * @returns Array of sessions
   */
  public async findMany(
    where: Prisma.SessionWhereInput = {},
    options: Omit<Prisma.SessionFindManyArgs, 'where'> = {}
  ): Promise<Session[]> {
    const sessions = await this.prisma.session.findMany({ where, ...options });

    if (sessions.length > 0) this.events.emit('entity.session.accessed.multiple', sessions, { where, ...options });

    return sessions;
  }

  /**
   * Create a new session
   * @param data Session data
   * @param options Additional Prisma create options
   * @returns Created session
   */
  public async create(data: Prisma.SessionCreateInput, options: Omit<Prisma.SessionCreateArgs, 'data'> = {}): Promise<Session> {
    const session = await this.prisma.session.create({ data, ...options });

    this.events.emit('entity.session.created.single', session, { data, ...options });

    return session;
  }

  /**
   * Create multiple sessions
   * @param data Array of session data
   * @param options Additional Prisma createMany options
   * @returns Batch payload with count of created records
   */
  public async createMany(
    data: Prisma.SessionCreateManyInput[],
    options: Omit<Prisma.SessionCreateManyArgs, 'data'> = {}
  ): Promise<Prisma.BatchPayload> {
    const sessions = await this.prisma.session.createMany({ data, ...options });

    this.events.emit('entity.session.created.multiple', sessions, { data, ...options });

    return sessions;
  }

  /**
   * Upsert a session (create or update)
   * @param where Unique criteria to find the session
   * @param createData Data to create if session does not exist
   * @param updateData Data to update if session exists
   * @param options Additional Prisma upsert options
   * @returns Upserted session
   */
  public async upsert(
    where: Prisma.SessionWhereUniqueInput,
    createData: Prisma.SessionCreateInput,
    updateData: Prisma.SessionUpdateInput,
    options: Omit<Prisma.SessionUpsertArgs, 'where' | 'create' | 'update'> = {}
  ): Promise<Session> {
    const session = await this.prisma.session.upsert({ where, create: createData, update: updateData, ...options });

    this.events.emit('entity.session.upserted', session, { where, create: createData, update: updateData, ...options });

    return session;
  }

  /**
   * Update a session by ID
   * @param id Session ID
   * @param data Data to update
   * @param options Additional Prisma update options
   * @returns Updated session
   */
  public async update(
    id: string,
    data: Prisma.SessionUpdateInput,
    options: Omit<Prisma.SessionUpdateArgs, 'where' | 'data'> = {}
  ): Promise<Session> {
    const session = await this.prisma.session.update({ where: { id }, data, ...options });

    this.events.emit('entity.session.updated.single', session, { id, data, ...options });

    return session;
  }

  /**
   * Update multiple sessions by criteria
   * @param where Criteria to select sessions to update
   * @param data Data to update
   * @param options Additional Prisma updateMany options
   * @returns Batch payload with count of updated records
   */
  public async updateMany(
    where: Prisma.SessionWhereInput,
    data: Prisma.SessionUpdateManyMutationInput,
    options: Omit<Prisma.SessionUpdateManyArgs, 'where' | 'data'> = {}
  ): Promise<Prisma.BatchPayload> {
    const sessions = await this.prisma.session.updateMany({ where, data, ...options });

    this.events.emit('entity.session.updated.multiple', sessions, { where, data, ...options });

    return sessions;
  }

  /**
   * Delete a session by ID
   * @param id Session ID
   * @param options Additional Prisma delete options
   * @returns Deleted session
   */
  public async delete(id: string, options: Omit<Prisma.SessionDeleteArgs, 'where'> = {}): Promise<Session> {
    const session = await this.prisma.session.delete({ where: { id }, ...options });

    this.events.emit('entity.session.deleted.single', session, { id, ...options });

    return session;
  }

  /**
   * Delete multiple sessions by criteria
   * @param where Criteria to select sessions to delete
   * @param options Additional Prisma deleteMany options
   * @returns Batch payload with count of deleted records
   */
  public async deleteMany(
    where: Prisma.SessionWhereInput,
    options: Omit<Prisma.SessionDeleteManyArgs, 'where'> = {}
  ): Promise<Prisma.BatchPayload> {
    const sessions = await this.prisma.session.deleteMany({ where, ...options });

    this.events.emit('entity.session.deleted.multiple', sessions, { where, ...options });

    return sessions;
  }

  /**
   * Aggregate sessions by criteria
   * @param where Criteria to filter sessions
   * @param options Prisma aggregate options (excluding 'where')
   * @returns Aggregated session data
   */
  public async aggregate(where: Prisma.SessionWhereInput = {}, options: Omit<Prisma.SessionAggregateArgs, 'where'> = {}) {
    const result = await this.prisma.session.aggregate({ where, ...options });

    this.events.emit('entity.session.aggregated', result, { where, ...options });

    return result;
  }

  /**
   * Count sessions by criteria
   * @param where Criteria to count sessions
   * @param options Additional Prisma count options
   * @returns Count of sessions matching criteria
   */
  public async count(where: Prisma.SessionWhereInput = {}, options: Omit<Prisma.SessionCountArgs, 'where'> = {}) {
    const count = await this.prisma.session.count({ where, ...options });

    this.events.emit('entity.session.counted', count, { where, ...options });

    return count;
  }
}
